<script type='text/javascript'>
// function parseXML(xmlString) {
//   //just one approach, time will tell if another one will be implemented
//   var wrapper= document.createElement('div');
//   wrapper.innerHTML= xmlString;
//   var div= wrapper.firstChild;
//   var fragment = document.createDocumentFragment();
//   Array.from(wrapper.childNodes).forEach((node)=>{
//     console.log(node);
//     fragment.appendChild(node);
//   })

//   return fragment;
// }
function executeScriptTags(scripts) {
  scripts.forEach( function(scriptText){
    var head = document.getElementsByTagName("head")[0] ||
              document.documentElement,
    script = document.createElement("script");

    script.type = "text/javascript";
    try {
      script.appendChild(document.createTextNode(scriptText));      
    } catch(e) {
      script.text = scriptText;
    }
    head.insertBefore(script, head.firstChild);
    head.removeChild(script);
  });
}

function initializeRoutes(){
  window.history.pushState({'_spa_PATH':'/'},'','/');
  dispatchEvent(new PopStateEvent('popstate',{state:{'_spa_PATH':'/'}}));
}

function getScriptsContentInDoc(innerHTML){
  var scriptContentRE = /<script\b[^>]*>([\s\S]*?)<\/script>/gm;

  var match;
  var scripts = [];
  while (match = scriptContentRE.exec(innerHTML)) {
    scripts.push(match[1]);
  }
  return scripts;
}

function handlePopChange (event, routeComponents) {
      // console.log('HandleStateChange function invoked', event)
  // console.log(event,routeComponents)

  if ( event.state && event.state._spa_PATH ) {

    let pathname = event.state._spa_PATH;
    //console.time('forloop')
    for ( let i = 0; i < routeComponents.length; i++ ) {
      setTimeout(()=>{
        routeComponent = routeComponents[i];
        if ( routeComponent.path === pathname ) {
          
          routeComponent.render.call(routeComponent);
        } else {
          if ( routeComponent.shadowRoot.innerHTML ) {
            //implementation subject to change

            routeComponent.shadowRoot.innerHTML = '';

          }
        }
      },0)
    }
    //console.timeEnd('forloop');
  }
}

function handleListenerBound ( handleChangeListener, ...args ) {
  return ( ...eventArgs ) => {
    // console.trace();
    // console.log ( eventArgs, args );
    handleChangeListener.call(this, ...eventArgs, ...args );
  }
}
function clearShadowDOM(component){
  component.shadowRoot.innerHTML = '';
}
function fillShadowDOM(component, content) {
          // below commented since innerHTML seems to parse shadow dom fine
        // console.log("before invoking",context)
        // var parsedNodes = parseXML ( data );
        // console.dir(parsedNodes);
        // // var nodes = Array.from ( parsedNodes );
        // //console.log(nodes);
        // console.dir(context);

        // nodes.forEach ( function ( node ) {
        //   //console.log(node, context);
        // context.shadowRoot.appendChild ( node );
        // })
        // context.root.appendChild(parsedNodes);
        component.shadowRoot.innerHTML=content;
        //console.trace();

}
function preCacheRoute(elementToCache) {

  //console.trace();
  //console.log('element precached',elementToCache)
  return fetch(elementToCache.src);
  // (elementsToCache.reduce( ( chain, elem )=>{
 
  //   // console.log('element to cache', elem)
  //   return chain.then((data) => {
  //     // console.log(data);
  //     return fetch(elem.getFileSrc())
  //   })
  // }, Promise.resolve())).catch(err=>console.log(err));
}

</script>