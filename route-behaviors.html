<link rel='import' href='helper-functions.html'></script>
<script>

var routeBehaviours = function routeBehaviors(superClass) {
  var _routeComponents = [];
  var handleBound = ()=>((state)=>handleStateChange.call(this,state,_routeComponents))
  window.addEventListener('popstate',handleBound());
  window.addEventListener('DOMConentLoaded',initializeRoutes())
  return class extends superClass {
    
    ready() {
      super.ready();
      _routeComponents.push(this);
      // console.log(_routeComponents);
    }

    render() {
      //console.log(this.path);
      var relativePathname = window.location.pathname.substr(window.location.pathname.lastIndexOf('/'));
      //check index component for children in light DOM 
      if( (relativePathname ==='/' || relativePathname ==='/index.html') && this.path === '/') {
        if ( !this.src ) {
          this.shadowRoot.appendChild ( document.createElement('slot') );
          return;
        }
      }
      //check to see if src has been specified other-wise default to this.path+'.html'
      if ( this.src ) {
        var fileSrc = this.src;
      } else {
        var fileSrc =  this.path+'.html';
        //console.log(fileSrc)
      }

      var context = this;
      fetch(fileSrc)
        .then(function(data) {
          //console.log(data);
          return data.text();
        })
        .then(function(data) {
        // below commented since innerHTML seems updated all nodes accordingly
        console.log("before invoking",context)
        var parsedNodes = parseXML ( data );
        console.dir(parsedNodes);
        // var nodes = Array.from ( parsedNodes );
        //console.log(nodes);
        console.dir(context);
        context.shadowRoot.innerHTML = '';
        // nodes.forEach ( function ( node ) {
        //   //console.log(node, context);
        // context.shadowRoot.appendChild ( node );
        // })
        context.root.appendChild(parsedNodes);
        // context.distributeSlot(true); 
        // context.innerHTML=data;
        executeEmbeddedJavascript(getScriptsContentInDoc(context.shadowRoot.innerHTML));
        })
        .catch(function errored(err){
          console.log(err);
        })
    }
        
  // Will implement with data-binding functionality when needed
  // injectBoundHTML: function injectBoundHTML(html, element) {
  //   var template = document.createElement('template', 'dom-bind');
  //   var doc = template.content.ownerDocument;
  //   var div = doc.createElement('div');
  //   div.innerHTML = html;
  //   template.content.appendChild(div);
  //   while (element.firstChild) {
  //       element.removeChild(element.firstChild);
  //   }
  //   element.appendChild(Polymer.Base.instanceTemplate(template));
  // },
  // isLoaded: function() {
  //   return 
  // },
  }
}
var loadListenerAttached = false; 
var handleStateChange = function(event, routeComponents) {
      console.log('HandleStateChange function invoked', event)
      if( !event.state ) {
      } else if ( event.state._spa_PATH ) {

        let pathname = event.state._spa_PATH;
        for ( var i = 0; i < routeComponents.length; i++ ) {

          routeComponent = routeComponents[i];
          if ( routeComponent.path === pathname ) {
            routeComponent.render.call(routeComponent);
          } else {
            if ( routeComponent.innerHTML ) {
              //implementation subject to change
              routeComponent.shadowRoot.innerHTML = '';
            }
          }
        }
      }
    }
</script>