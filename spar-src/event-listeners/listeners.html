<link rel='import' href='../helper/helper-functions.html'>
<script>
  /**
 * Called on 'popstate'. Starts fetch-async/append-sync algorithm
 * @param {event} event - event object from 'pop' listener
 * @param {array} routeElements - array of route elements
 */
function precheckFetch ( event, routeElements ) {
  // fetch only if popstate was triggered by navigation button
  if ( event.state && event.state._spa_PATH ) {
    let pathname = event.state._spa_PATH;
    initializeFetching(pathname, routeElements);
  }
}
/**
 * Called on 'load': pushstate the index path and starts the fetch-async/append-sync algorithm for routes
 * @param {event} event - event object from 'load' listener 
 * @param {array} routeElements - array of route elements
 */
function loadIndexRoutes ( event, routeElements ) {
  window.history.pushState({'_spa_PATH':'/'},'','/');
  initializeFetching( '/', routeElements );
}
/**
 * Clears all shadowDOMs and fetches files
 * @param {string} urlPathname - url string to compare routes to
 * @param {array} routeElements - array of route elements
 */
function initializeFetching ( urlPathname, routeElements )  {
    var matchingRoutes = [];

    routeElements.forEach( function ( comp ) {
      // console.log(comp);
      if ( comp.pathParsed === urlPathname ) {
        matchingRoutes.push(comp);
      }
    });

    // clearing deferred so as to not block fetching
    setTimeout(()=>{routeElements.forEach((route)=>clearShadowDOM( route ));},0);
    fetchAndAppendRoutes( urlPathname, matchingRoutes );
}
/**
 * Pre-caches route files
 *  @param {element} element - route element
 */
function preCacheRoute ( event, elements ) {
  // algorithm may need change for onload implementation
  
  elements.forEach ( function ( element ) {
    if ( element.src && element.pathParsed !== '/' ) {
      fetch(element.src);
    }
  });
}
/**
 * Passes event object and any parameters into event listener
 * @param {fn} handleChangeListener - event listener
 * @param {array} args - arguments passed to event listener
 * @return event listener callback
 */
function handleListenerBound ( handleChangeListener, ...args ) {
  return ( event ) => {
    handleChangeListener.call(this, event, ...args );
  }
}
</script>