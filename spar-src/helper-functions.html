<script type='text/javascript'>
//place all in object
function parseXML(xmlString) {
  // console.log(xmlString);
  //creates document fragment from string
  return document.createRange().createContextualFragment(xmlString);
}

function initializeRoutes(e, routeComponents){
  console.log('Routes Initializing',e,routeComponents);
  window.history.pushState({'_spa_PATH':'/'},'','/');
  initializeDiff('/', routeComponents);
}

function handlePopChange (event, routeComponents) {
  // console.trace();
  // console.log('HandleStateChange function invoked', event)
  // console.log(event,routeComponents.map(elem=>elem.src))
  // check to that the popstate was triggered by spar-link
  if ( event.state && event.state._spa_PATH ) {
    let pathname = event.state._spa_PATH;
    //console.time('render')
    //console.timeEnd('render');
    // console.count();
    initializeDiff(pathname, routeComponents);
  }
}
function initializeDiff ( urlPathname, routeComponents )  {
    var routes = [];
    var nonRoutes = [];
    routeComponents.forEach( function ( comp ) {
      if ( comp.pathParsed === urlPathname ) {
        //console.log(comp.pathParsed, urlPathname)
        routes.push(comp);
      } else {
        //console.log(comp.pathParsed, urlPathname)
        nonRoutes.push(comp);
      }
    })
    setTimeout(()=>{nonRoutes.forEach((route)=>clearShadowDOM( route ));},0);
    renderDiff( urlPathname, routes );
}
function renderDiff ( urlPathname, routeComponents, invokeLater) {
  let  renderSyncFn = renderSyncThunk ( routeComponents.length, invokeLater );

  //turn into for each
  if ( routeComponents.length === 0 ) {
    return; 
  }
  routeComponents.forEach((routeComponent, thkOrderTracker)=>{

    routeComponent.fetchOrRender.call(routeComponent).then ( function postFetch ( xml ) {
      // may need to consider edge case for 'undefined' xml
      if(typeof xml === 'undefined'){
        return;
      }
      xml = parseShadowDOM( routeComponent, xml );
      var subRoutes = xml.querySelectorAll('spar-route');
      if ( subRoutes.length === 0) {
        renderSyncFn ( thkOrderTracker, routeComponent, xml );
      } else {

        renderDiff ( window.location.pathname, subRoutes, invocLaterThunk (renderSyncFn, thkOrderTracker, routeComponent, xml) );
      }
    });
  });
}
function invocLaterThunk(cb, ...arg) {
  return function () {
    cb(...arg);
  }
}
function renderSyncThunk(length, laterCb) {
  var components = [];
  var contents = [];
  var counter = 0;
  return function renderSync ( index, component, content ) {
    components[index] = component;
    contents[index] = content;
    if ( index === counter ) {
      while(components[counter]) {
        console.log(components[counter], counter);
        clearShadowDOM(components[counter]); 
        components[counter].shadowRoot.appendChild(contents[counter]);
        counter++;
      }
    }
    if ( length === counter && laterCb ) {
      laterCb();
    }
  }
}

function parseShadowDOM ( component, content ) {
  // below commented since innerHTML seems to parse shadow dom fine
  // console.log("before invoking",context);
  var parsedNodes = parseXML ( content );

  return parsedNodes;
  //console.trace();
}
function handleListenerBound ( handleChangeListener, ...args ) {
  return ( ...eventArgs ) => {

    // console.trace();
    // console.log ( eventArgs, args );
    handleChangeListener.call(this, ...eventArgs, ...args );
  }
}
function clearShadowDOM(component) {
  typeof component.shadowRoot === 'undefined' && console.log('undefined shadowroot',component);
  if ( component.shadowRoot.innerHTML ) {
    // console.trace();
    console.log('Cleared:',component,component.path);
    while(component.shadowRoot.firstChild) {
      component.shadowRoot.removeChild(component.shadowRoot.firstChild);
    }
  }
}


function preCacheRoute(elementToCache) {
  // consider link preload for precaching
  // algorithm may need change for onload implementation
  if(elementToCache.src) {
    fetch(elementToCache.src);
  }
}


</script>