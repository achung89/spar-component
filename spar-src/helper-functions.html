<script type='text/javascript'>
function parseXML(xmlString) {
  //just one approach, time will tell if another one will be implemented
  var wrapper= document.createElement('div');
  wrapper.innerHTML= xmlString;
  var div= wrapper.firstChild;
  var fragment = document.createDocumentFragment();
  Array.from(wrapper.childNodes).forEach((node)=>{
    console.log(node);
    fragment.appendChild(node);
  })

  return fragment;
}
function executeScriptTags(scripts) {
  scripts.forEach( function appendScriptTag(scriptText){
    var head = document.getElementsByTagName("head")[0] ||
              document.documentElement,
    script = document.createElement("script");

    script.type = "text/javascript";
    try {
      script.appendChild(document.createTextNode(scriptText));      
    } catch(e) {
      script.text = scriptText;
    }
    head.insertBefore(script, head.firstChild);
    head.removeChild(script);
  });
}

function initializeRoutes(){
  console.log('Routes Initializing');
  window.history.pushState({'_spa_PATH':'/'},'','/');
  dispatchEvent(new PopStateEvent('popstate',{state:{'_spa_PATH':'/'}}));
}

function getScriptsContentInDoc(innerHTML){
  var scriptContentRE = /<script\b[^>]*>([\s\S]*?)<\/script>/gm;

  var match;
  var scripts = [];
  while (match = scriptContentRE.exec(innerHTML)) {
    scripts.push(match[1]);
  }
  return scripts;
}

function handlePopChange (event, routeComponents) {
  console.trace();
      // console.log('HandleStateChange function invoked', event)
  console.log(event,routeComponents.map(elem=>elem.src))
  if ( event.state && event.state._spa_PATH ) {

    let pathname = event.state._spa_PATH;
    //console.time('forloop')
    for ( let i = 0; i < routeComponents.length; i++ ) {
        routeComponent = routeComponents[i];
        if ( routeComponent.path === pathname ) {
          
          routeComponent.render.call(routeComponent);
        } else {
          if ( routeComponent.shadowRoot.innerHTML ) {
            //implementation subject to change

            routeComponent.shadowRoot.innerHTML = '';

          }
        }
      }
    }
    //console.timeEnd('forloop');
  }


function handleListenerBound ( handleChangeListener, ...args ) {
  return ( ...eventArgs ) => {

    // console.trace();
    // console.log ( eventArgs, args );
    handleChangeListener.call(this, ...eventArgs, ...args );
  }
}
function clearShadowDOM(component){
  component.shadowRoot.innerHTML = '';
}
function fillShadowDOM(component, content) {
        // below commented since innerHTML seems to parse shadow dom fine
        // console.log("before invoking",context)
        var parsedNodes = parseXML ( content );
        component.shadowRoot.appendChild(parsedNodes);
        //console.trace();

}
function preCacheRoute(elementToCache) {
  //consider using link preload for precaching
  //console.trace();
  //console.log('element precached',elementToCache)
  console.log(elementToCache);
  return fetch(elementToCache.src);
  // (elementsToCache.reduce( ( chain, elem )=>{
 
  //   // console.log('element to cache', elem)
  //   return chain.then((data) => {
  //     // console.log(data);
  //     return fetch(elem.getFileSrc())
  //   })
  // }, Promise.resolve())).catch(err=>console.log(err));
}

</script>