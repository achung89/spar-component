<script type='text/javascript'>
function parseXML(xmlString) {
  // console.log(xmlString);
  //creates document fragment from string
  return document.createRange().createContextualFragment(xmlString);
}

function initializeRoutes(e, routeComponents){
  console.log('Routes Initializing',e,routeComponents);
  window.history.pushState({'_spa_PATH':'/'},'','/');
  renderDiff('/',routeComponents);
}

function handlePopChange (event, routeComponents) {
  // console.trace();
  // console.log('HandleStateChange function invoked', event)
  // console.log(event,routeComponents.map(elem=>elem.src))
  if ( event.state && event.state._spa_PATH ) {
    let pathname = event.state._spa_PATH;
    //console.time('render')
    renderDiff(pathname, routeComponents)
    //console.timeEnd('render');
    console.count();
  }

}

function renderDiff ( urlPathname, routeComponents ) {
  for ( let i = 0; i < routeComponents.length; i++ ) {
      routeComponent = routeComponents[i];
      // console.log(routeComponent.pathParsed,urlPathname)
      if ( routeComponent.pathParsed === urlPathname ) {
        
        routeComponent.render.call(routeComponent);
      } else {
        if ( routeComponent.shadowRoot.innerHTML ) {
          //implementation subject to change

          routeComponent.shadowRoot.innerHTML = '';

        }
      }
    }
}
function handleListenerBound ( handleChangeListener, ...args ) {
  return ( ...eventArgs ) => {

    // console.trace();
    // console.log ( eventArgs, args );
    handleChangeListener.call(this, ...eventArgs, ...args );
  }
}
function clearShadowDOM(component){
  component.shadowRoot.innerHTML = '';
}
function fillShadowDOM(component, content) {
  // below commented since innerHTML seems to parse shadow dom fine
  // console.log("before invoking",context)
  var parsedNodes = parseXML ( content );
  // parsedNodes.querySelectorAll('script').forEach(function(script) {
  //   //doesn't work
  //   console.log(`${script.src}`);
  //   script.src = `${script.src}`;
  // })
  var subRoutes = parsedNodes.querySelectorAll('spar-route');
  renderDiff(window.location.pathname,subRoutes);
  component.shadowRoot.appendChild(parsedNodes);

  //console.trace();
}
function preCacheRoute(elementToCache) {
  // consider link preload for precaching
  // algorithm may need change for onload implementation
  if(elementToCache.src) {
    fetch(elementToCache.src);
  }
}

</script>