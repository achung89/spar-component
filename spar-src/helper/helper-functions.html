<script type='text/javascript'>
//place all in object
function parseXML(xmlString) {
  // console.log(xmlString);
  //creates document fragment from string
  return document.createRange().createContextualFragment(xmlString);
}

function loadIndexRoutes(e, routeComponents){
  console.log('Routes Initializing',e,routeComponents);
  window.history.pushState({'_spa_PATH':'/'},'','/');
  initializeFetching( '/', routeComponents );
}

function initializeLoading ( event, routeComponents ) {
  // console.log('HandleStateChange function invoked', event)
  // console.log(event,routeComponents.map(elem=>elem.src))

  // only starts the fetch if popstate was not triggered by third party
  if ( event.state && event.state._spa_PATH ) {
    let pathname = event.state._spa_PATH;
    initializeFetching(pathname, routeComponents);
  }
}
function initializeFetching ( urlPathname, routeComponents )  {
    var matchingRoutes = [];
    var nonmatchingRoutes = [];
    routeComponents.forEach( function ( comp ) {
      if ( comp.pathParsed === urlPathname ) {
        //console.log(comp.pathParsed, urlPathname)
          matchingRoutes.push(comp);
      } else {
        //console.log(comp.pathParsed, urlPathname)
        nonmatchingRoutes.push(comp);
      }
    })

    // clearing set to callback so that it doesn't block fetching
    setTimeout(()=>{nonRoutes.forEach((route)=>clearShadowDOM( route ));},0);
    renderDiff( urlPathname, routes );
}
function renderDiff ( urlPathname, routeComponents, invokeLater ) {
  var frameFile = {};
  if ( routeComponents.length === 0 ) {
    return;
  }
  let  renderSyncFn = renderSyncThunk ( routeComponents.length, invokeLater );
  routeComponents.forEach( ( routeComponent, thkIndex ) => {
    // may not need 'call', check when tests are setup
    var fetch = true;
    if ( routeComponent.frameId ) {
      fetch = shouldFetch( frameFile, routeComponent, thkIndex )
    }

    if ( !routeComponent.src ) {
      renderSyncFn(thkIndex, routeComponent, document.createElement('slot') )
    } else if ( fetch ) {
      // console.log(routeComponent);
      routeComponent.fetchOrRender.call(routeComponent).then ( function postFetch ( xmlText ) {
        console.log ( xmlText );
        xml = parseShadowDOM( routeComponent, xmlText );
        if ( frameFile[routeComponent.src] ) {
          frameFile[routeComponent.src].forEach ( function ([ comp, indexThk ]) {
            var frameXml = xml.querySelectorAll(`spar-frame[id="${comp.frameId}"]`);
            if ( frameXml.length > 1 ) {
              throw 'Can not have multiple tags with same frame id per document';
            } else if ( frameXml.length === 0 ) {
              throw 'Can not find spar-frame id="'+'"';
            } else {
              //console.log( frameXml )
              let subroutes = subroutesCheck(comp,frameXml[0]);

              let parsed = parseXML(frameXml[0].innerHTML);
              console.log(parsed, frameXml[0].innerHTML);
              let params = [renderSyncFn, indexThk, comp, parsed];
              recurseOrRender ( subroutes, ...params );
            }
          })
        } else {
        //test this express
          let subroutes = subroutesCheck(routeComponent,xml);
          let params = [renderSyncFn, thkIndex, routeComponent, xml];
          recurseOrRender ( subroutes, ...params );
        }
      });
    }
  });
}
function shouldFetch ( frameFile, routeComponent, thkIndex ) {
    if ( frameFile[routeComponent.src] ) {
      frameFile[routeComponent.src].push([routeComponent,thkIndex]);
      return false;
    } else {      
      frameFile[routeComponent.src]=[[routeComponent,thkIndex]];
      return true;
    }
}
function recurseOrRender (subroutes, ...args) {
    if ( subroutes ) {
      console.log('invoking recursive renderDiff',subroutes, window.location.pathname)
      //window.location.pathname may not be right metric for comparison
      renderDiff ( window.location.pathname, subroutes, callLater ( ...args ) );
    } else {
      //console.log(args[0]);
      args[0] ( args[1], args[2], args[3] );
    }
}
function subroutesCheck (routeComponent, xml) {
  if ( routeComponent.path === '/' ) {
    var subroutes = xml.querySelectorAll(`spar-index`);
  } else {
    var subroutes = xml.querySelectorAll(`spar-route[path="${routeComponent.path}"],spar-route[path="/${routeComponent.path}"]`);
  }
  // console.dir(xml.children.length);
  console.log(subroutes);
  if ( subroutes.length === 0) {
    //console.log('invoking renderySyncFn', routeComponent)
    return false;
  } else {
    return subroutes;
  }
}
function callLater(cb, ...arg) {
  return function () {
    cb ( ...arg );
  }
}
function renderSyncThunk(length, laterCb) {
  let components = [];
  let contents = [];
  let counter = 0;
  return function renderSync ( index, component, content ) {

    components[index] = component;
    contents[index] = content;
    if ( index === counter ) {
      while(components[counter]) {
        console.log(components[counter], counter, length-1);
        clearShadowDOM(components[counter]); 
        components[counter].shadowRoot.appendChild(contents[counter]);
        counter++;
      }
    }
    if ( length === counter && laterCb ) {
      console.log('invocLater was invoked');
      laterCb();
    }
  }
}

function parseShadowDOM ( component, content ) {
  // console.log("before invoking",context);
  var parsedNodes = parseXML ( content );
  return parsedNodes;
  //console.trace();
}
function handleListenerBound ( handleChangeListener, ...args ) {
  return ( ...eventArgs ) => {

    // console.trace();
    // console.log ( eventArgs, args );
    handleChangeListener.call(this, ...eventArgs, ...args );
  }
}
function clearShadowDOM(component) {
  typeof component.shadowRoot !== 'object' && console.log('undefined shadowroot', component);
  if ( component.shadowRoot.innerHTML ) {
    // console.trace();
    // console.log('Cleared:',component,component.path);
    while(component.shadowRoot.firstChild) {
      component.shadowRoot.removeChild(component.shadowRoot.firstChild);
    }
  }
}


function preCacheRoute(elementToCache) {
  // consider link preload for precaching
  // algorithm may need change for onload implementation
  if(elementToCache.src) {
    fetch(elementToCache.src);
  }
}

</script>