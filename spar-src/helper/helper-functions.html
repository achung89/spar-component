<script>

/** takes and outputs a parsed XML
 * @param {string} xmlString string to be parsed
 */
function parseXML(xmlString) {
  return document.createRange().createContextualFragment(xmlString);
}

/**
 * called on 'load': pushstate the index path and starts the fetch-async/append-sync algorithm for routes
 * @param {event} e event from 'load' listener 
 * @param {array} routeElements array of route elements
 */
function loadIndexRoutes(e, routeElements){
  window.history.pushState({'_spa_PATH':'/'},'','/');
  initializeFetching( '/', routeElements );
}

/**
 * called on 'popstate': starts fetch-asyng/append-sync algorithm
 * @param {event} event event from 'pop' listener
 * @param {array} routeElements 
 */
function initializeLoading ( event, routeElements ) {

  // fetch only if popstate was not triggered by a third party
  if ( event.state && event.state._spa_PATH ) {
    let pathname = event.state._spa_PATH;
    initializeFetching(pathname, routeElements);
  }
}

/**
 * 
 * @param {string} urlPathname 
 * @param {array} routeElements array of route elements
 */
function initializeFetching ( urlPathname, routeElements )  {
    var matchingRoutes = [];
    var nonmatchingRoutes = [];
    routeElements.forEach( function ( comp ) {
      if ( comp.pathParsed === urlPathname ) {
          matchingRoutes.push(comp);
      } else {
        nonmatchingRoutes.push(comp);
      }
    })

    // clearing set to callback so that it doesn't block fetching
    setTimeout(()=>{nonmatchingRoutes.forEach((route)=>clearShadowDOM( route ));},0);
    renderDiff( urlPathname, matchingRoutes );
}

/**
 * Recursive tree algorithm to fetch files asynchronously and appends them synchronously
 * @param {string} urlPathname pushstate path
 * @param {array} routeElements array of elements to be fetched and later rendered
 * @param {function) invokeLater a function which delays the 'syncRender' invocation on an element until all its subroutes have been fetched and appended
 */
function renderDiff ( urlPathname, routeElements, invokeLater ) {

  // frameFile will hold a list of routes with a frame id
  var frameFile = {};
  if ( routeElements.length === 0 ) {
    return;
  }
  let  renderSyncFn = renderSyncThunk ( routeElements.length, invokeLater );
  routeElements.forEach( ( routeElement, orderOnPage ) => {
    // may not need 'call', check when tests are setup
    var fetch = true;
    if ( routeElement.frameId ) {
      fetch = pushAndReturnFetchVal( frameFile, routeElement, orderOnPage )
    }

    if ( !routeElement.src ) {
      renderSyncFn(orderOnPage, routeElement, document.createElement('slot') )
    } else if ( fetch ) {
      routeElement.fetchOrRender.call(routeElement).then ( function postFetch ( xmlText ) {
        var xml = parseXML( xmlText );

        if ( frameFile[routeElement.src] ) {
          frameFile[routeElement.src].forEach ( function ([ comp, pageOrder ]) {
            var frameXml = xml.querySelectorAll(`spar-frame[id="${comp.frameId}"]`);
            if ( frameXml.length > 1 ) {
              throw 'Can not have multiple tags with same frame id per document';
            } else if ( frameXml.length === 0 ) {
              throw 'Can not find spar-frame id="'+'"';
            } else {
              var subroutes = subroutesCheck(comp,frameXml[0]);
              var parsed = parseXML(frameXml[0].innerHTML);
              var params = [pageOrder, comp, parsed];
              fetchSubroutesOrRender ( subroutes, renderSyncFn, ...params );
            }
          })
        } else {
          var subroutes = subroutesCheck(routeElement,xml);
          var params = [orderOnPage, routeElement, xml];
          fetchSubroutesOrRender ( subroutes, renderSyncFn, ...params );
        }
      });
    }
  });
}

/**
 * Stores element if it is fetching a frame. Returns false if the file has already been fetched
 * @param {object} frameFile holds information regarding element
 * @param {spar element} routeElement  
 * @param {number} orderOnPage order of element to be rendered in 'render-sync' 
 */
function pushAndReturnFetchVal( frameFile, routeElement, orderOnPage ) {
    console.log("pushed frame component",routeElement,orderOnPage)
    if ( frameFile[routeElement.src] ) {
      frameFile[routeElement.src].push([routeElement,orderOnPage]);
      return false;
    } else {      
      frameFile[routeElement.src]=[[routeElement,orderOnPage]];
      return true;
    }
}

/**
 * checks if fetched children of spar route contains any spar elements
 * @param {element} routeElement parent element
 * @param {nodes} xml fetched children
 */
function subroutesCheck (routeElement, xml) {
  if ( routeElement.path === '/' ) {
    var subroutes = xml.querySelectorAll(`spar-index`);
  } else {
    var subroutes = xml.querySelectorAll(`spar-route[path="${routeElement.path}"],spar-route[path="/${routeElement.path}"]`);
  }
  // console.dir(xml.children.length);
  console.log(subroutes);
  if ( subroutes.length === 0) {
    //console.log('invoking renderySyncFn', routeElement)
    return false;
  } else {
    return subroutes;
  }
}

/**
 * If subroutes exist, recursively call fetch on children. If not, 
 * @param {array} subroutes nested spar components 
 * @param args 
 */
function fetchSubroutesOrRender (subroutes, renderSyncFn, ...args) {
    if ( subroutes ) {
      console.log('invoking recursive renderDiff',subroutes, window.location.pathname)
      //window.location.pathname may not be right metric for comparison
      renderDiff ( window.location.pathname, subroutes, callLater ( renderSyncFn, ...args ) );
    } else {
      renderSyncFn ( args[0], args[1], args[2] );
    }
}

/**
 * Thunk stores callback invocation and its parameters
 * @param {function} cb renderSyncFn
 * @param {array} arg parameters
 */
function callLater(cb, ...arg) {
  return function () {
    cb ( ...arg );
  }
}

/**
 * This thunk contains the async-fetch/sync-append algorithm. When components are fetched, this function is called and
 * stores the component and its contents into a closure. Only if the element is next in line will it's children be appended.
 * After all elements children are appended, the renderSync function will be called on its parent if the parent exists.
 * @param {number} length length of array of components, when counter equals length, syncRender is called on its parent spar element
 * @param {function} laterCb result of 'callLater' which, on invocation, calls syncRender on parent spar element
 */
function renderSyncThunk(length, laterCb) {
  let components = [];
  let contents = [];
  let counter = 0;
  return function renderSync ( index, component, content ) {

    components[index] = component;
    contents[index] = content;
    if ( index === counter ) {
      while(components[counter]) {
        console.log(components, components[counter], counter, length-1);
        clearShadowDOM(components[counter]); 
        components[counter].shadowRoot.appendChild(contents[counter]);
        counter++;
      }
    }
    if ( length === counter && laterCb ) {
      console.log('invocLater was invoked');
      laterCb();
    }
  }
}
function handleListenerBound ( handleChangeListener, ...args ) {
  return ( ...eventArgs ) => {

    // console.trace();
    // console.log ( eventArgs, args );
    handleChangeListener.call(this, ...eventArgs, ...args );
  }
}
function clearShadowDOM(component) {
  typeof component.shadowRoot !== 'object' && console.log('undefined shadowroot', component);
  if ( component.shadowRoot.innerHTML ) {
    // console.trace();
    // console.log('Cleared:',component,component.path);
    while(component.shadowRoot.firstChild) {
      component.shadowRoot.removeChild(component.shadowRoot.firstChild);
    }
  }
}


function preCacheRoute(elementToCache) {
  // consider link preload for precaching
  // algorithm may need change for onload implementation
  if(elementToCache.src) {
    fetch(elementToCache.src);
  }
}

 </script>



<script>
(()=>{
  var supportsCustomElementsV1 = supportsCustomElementsV1 || null;
  var supportsShadowDOMV1 = supportsShadowDOMV1 || null;
  function loadScript(src) {
    return new Promise(function(resolve, reject) {
      const script = document.createElement('script');
      script.src = src;
      script.onload = resolve;
      script.onerror = reject;
      document.head.appendChild(script);
    });
  }
  //polyfill 
  // Lazy load the polyfill if necessary.
  if (!supportsCustomElementsV1) {
    loadScript('/bower_components/custom-elements/custom-elements.min.js').then(e => {
      console.log('CustomElements polyfill loaded');
    }).catch(e=>{
      supportsCustomElementsV1 = null;
    })
  }
  //fix this polyfill script
  function loadScriptShadow(src) {
    return new Promise(function(resolve, reject) {
      const script = document.createElement('script');
      script.src = src;
      script.onload = resolve;
      script.onerror = reject;
      document.head.appendChild(script);
    });
  }

  // Lazy load the polyfill if necessary.
  if (!supportsShadowDOMV1) {
    loadScriptShadow('/bower_components/shadydom/shadydom.min.js').then(e => {
      return loadScriptShadow('/bower_components/shadycss/scoping-shim.min.js')}).then(e => {
      return loadScriptShadow('/bower_components/shadycss/apply-shim.min.js')}).then(e => {
      return loadScriptShadow('/bower_components/shadycss/custom-style-interface.min.js')}).then(e => {
          console.log('ShadowDOM polyfill loaded');
    });
  }
})();
</script>