<script type='text/javascript'>

function parseXML(xmlString) {

  //creates document fragment from string
  return document.createRange().createContextualFragment(xmlString);
}

function loadIndexRoutes(e, routeComponents){
  window.history.pushState({'_spa_PATH':'/'},'','/');
  initializeFetching( '/', routeComponents );
}

function initializeLoading ( event, routeComponents ) {

  // fetch only if popstate was not triggered by a third party
  if ( event.state && event.state._spa_PATH ) {
    let pathname = event.state._spa_PATH;
    initializeFetching(pathname, routeComponents);
  }
}
function initializeFetching ( urlPathname, routeComponents )  {
    var matchingRoutes = [];
    var nonmatchingRoutes = [];
    routeComponents.forEach( function ( comp ) {
      if ( comp.pathParsed === urlPathname ) {
          matchingRoutes.push(comp);
      } else {
        nonmatchingRoutes.push(comp);
      }
    })

    // clearing set to callback so that it doesn't block fetching
    setTimeout(()=>{nonmatchingRoutes.forEach((route)=>clearShadowDOM( route ));},0);
    renderDiff( urlPathname, matchingRoutes );
}
function renderDiff ( urlPathname, routeComponents, invokeLater ) {

  // frameFile will hold a list of routes with a frame id
  var frameFile = {};
  if ( routeComponents.length === 0 ) {
    return;
  }
  let  renderSyncFn = renderSyncThunk ( routeComponents.length, invokeLater );
  routeComponents.forEach( ( routeComponent, thkIndex ) => {
    // may not need 'call', check when tests are setup
    var fetch = true;
    if ( routeComponent.frameId ) {
      fetch = pushAndReturnFetchVal( frameFile, routeComponent, thkIndex )
    }

    if ( !routeComponent.src ) {
      renderSyncFn(thkIndex, routeComponent, document.createElement('slot') )
    } else if ( fetch ) {
      routeComponent.fetchOrRender.call(routeComponent).then ( function postFetch ( xmlText ) {
        var xml = parseShadowDOM( routeComponent, xmlText );

        if ( frameFile[routeComponent.src] ) {
          frameFile[routeComponent.src].forEach ( function ([ comp, indexThk ]) {
            var frameXml = xml.querySelectorAll(`spar-frame[id="${comp.frameId}"]`);
            if ( frameXml.length > 1 ) {
              throw 'Can not have multiple tags with same frame id per document';
            } else if ( frameXml.length === 0 ) {
              throw 'Can not find spar-frame id="'+'"';
            } else {
              var subroutes = subroutesCheck(comp,frameXml[0]);
              var parsed = parseXML(frameXml[0].innerHTML);
              var params = [renderSyncFn, indexThk, comp, parsed];
              recurseOrRender ( subroutes, ...params );
            }
          })
        } else {
          var subroutes = subroutesCheck(routeComponent,xml);
          var params = [renderSyncFn, thkIndex, routeComponent, xml];
          recurseOrRender ( subroutes, ...params );
        }
      });
    }
  });
}
function pushAndReturnFetchVal( frameFile, routeComponent, thkIndex ) {
    console.log("pushed frame component",routeComponent,thkIndex)
    if ( frameFile[routeComponent.src] ) {
      frameFile[routeComponent.src].push([routeComponent,thkIndex]);
      return false;
    } else {      
      frameFile[routeComponent.src]=[[routeComponent,thkIndex]];
      return true;
    }
}
function recurseOrRender (subroutes, ...args) {
    if ( subroutes ) {
      console.log('invoking recursive renderDiff',subroutes, window.location.pathname)
      //window.location.pathname may not be right metric for comparison
      renderDiff ( window.location.pathname, subroutes, callLater ( ...args ) );
    } else {
      //console.log(args[0]);
      args[0] ( args[1], args[2], args[3] );
    }
}
function subroutesCheck (routeComponent, xml) {
  if ( routeComponent.path === '/' ) {
    var subroutes = xml.querySelectorAll(`spar-index`);
  } else {
    var subroutes = xml.querySelectorAll(`spar-route[path="${routeComponent.path}"],spar-route[path="/${routeComponent.path}"]`);
  }
  // console.dir(xml.children.length);
  console.log(subroutes);
  if ( subroutes.length === 0) {
    //console.log('invoking renderySyncFn', routeComponent)
    return false;
  } else {
    return subroutes;
  }
}
function callLater(cb, ...arg) {
  return function () {
    cb ( ...arg );
  }
}
function renderSyncThunk(length, laterCb) {
  let components = [];
  let contents = [];
  let counter = 0;
  return function renderSync ( index, component, content ) {

    components[index] = component;
    contents[index] = content;
    if ( index === counter ) {
      while(components[counter]) {
        console.log(components, components[counter], counter, length-1);
        clearShadowDOM(components[counter]); 
        components[counter].shadowRoot.appendChild(contents[counter]);
        counter++;
      }
    }
    if ( length === counter && laterCb ) {
      console.log('invocLater was invoked');
      laterCb();
    }
  }
}

function parseShadowDOM ( component, content ) {
  // console.log("before invoking",context);
  var parsedNodes = parseXML ( content );
  return parsedNodes;
  //console.trace();
}
function handleListenerBound ( handleChangeListener, ...args ) {
  return ( ...eventArgs ) => {

    // console.trace();
    // console.log ( eventArgs, args );
    handleChangeListener.call(this, ...eventArgs, ...args );
  }
}
function clearShadowDOM(component) {
  typeof component.shadowRoot !== 'object' && console.log('undefined shadowroot', component);
  if ( component.shadowRoot.innerHTML ) {
    // console.trace();
    // console.log('Cleared:',component,component.path);
    while(component.shadowRoot.firstChild) {
      component.shadowRoot.removeChild(component.shadowRoot.firstChild);
    }
  }
}


function preCacheRoute(elementToCache) {
  // consider link preload for precaching
  // algorithm may need change for onload implementation
  if(elementToCache.src) {
    fetch(elementToCache.src);
  }
}

</script>



<script>
(()=>{
  var supportsCustomElementsV1 = supportsCustomElementsV1 || null;
  var supportsShadowDOMV1 = supportsShadowDOMV1 || null;
  function loadScript(src) {
    return new Promise(function(resolve, reject) {
      const script = document.createElement('script');
      script.src = src;
      script.onload = resolve;
      script.onerror = reject;
      document.head.appendChild(script);
    });
  }
  //polyfill 
  // Lazy load the polyfill if necessary.
  if (!supportsCustomElementsV1) {
    loadScript('/bower_components/custom-elements/custom-elements.min.js').then(e => {
      console.log('CustomElements polyfill loaded');
    }).catch(e=>{
      supportsCustomElementsV1 = null;
    })
  }
  //fix this polyfill script
  function loadScriptShadow(src) {
    return new Promise(function(resolve, reject) {
      const script = document.createElement('script');
      script.src = src;
      script.onload = resolve;
      script.onerror = reject;
      document.head.appendChild(script);
    });
  }

  // Lazy load the polyfill if necessary.
  if (!supportsShadowDOMV1) {
    loadScriptShadow('/bower_components/shadydom/shadydom.min.js').then(e => {
      return loadScriptShadow('/bower_components/shadycss/scoping-shim.min.js')}).then(e => {
      return loadScriptShadow('/bower_components/shadycss/apply-shim.min.js')}).then(e => {
      return loadScriptShadow('/bower_components/shadycss/custom-style-interface.min.js')}).then(e => {
          console.log('ShadowDOM polyfill loaded');
    });
  }
})();
</script>